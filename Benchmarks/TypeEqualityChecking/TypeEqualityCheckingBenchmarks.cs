//------------------------------------------------------------------------------
// <auto-generated>
//	This code was generated from the "TypeEqualityCheckingBenchmarks.tt" T4 Text Template.
// </auto-generated>
//------------------------------------------------------------------------------

using BenchmarkDotNet.Attributes;
using System.Runtime.CompilerServices;
using System;

namespace TypeEqualityChecking
{
	public class TypeEqualityCheckingBenchmarks
	{
		bool temp;

		[Benchmark]
		public void TypeOfEquals()
		{
			// true checks
			temp = typeof(string) == typeof(string);
			temp = typeof(int) == typeof(int);
			temp = typeof(double) == typeof(double);
			temp = typeof(decimal) == typeof(decimal);
			temp = typeof(byte) == typeof(byte);
			temp = typeof(short) == typeof(short);

			// false checks
			temp = typeof(string) == typeof(int);
			temp = typeof(int) == typeof(string);
			temp = typeof(double) == typeof(int);
			temp = typeof(decimal) == typeof(int);
			temp = typeof(byte) == typeof(int);
			temp = typeof(short) == typeof(int);
		}

		static bool TypeOfEqualsGeneric<A, B>() => typeof(A) == typeof(B);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		static bool TypeOfEqualsGenericInlined<A, B>() => typeof(A) == typeof(B);

		[Benchmark]
		public void TypeOfEqualsGeneric()
		{
			// true checks
			temp = TypeOfEqualsGeneric<string, string>();
			temp = TypeOfEqualsGeneric<int, int>();
			temp = TypeOfEqualsGeneric<double, double>();
			temp = TypeOfEqualsGeneric<decimal, decimal>();
			temp = TypeOfEqualsGeneric<byte, byte>();
			temp = TypeOfEqualsGeneric<short, short>();

			// false checks
			temp = TypeOfEqualsGeneric<string, int>();
			temp = TypeOfEqualsGeneric<int, string>();
			temp = TypeOfEqualsGeneric<double, int>();
			temp = TypeOfEqualsGeneric<decimal, int>();
			temp = TypeOfEqualsGeneric<byte, int>();
			temp = TypeOfEqualsGeneric<short, int>();
		}

		[Benchmark]
		public void TypeOfEqualsGenericInlined()
		{
			// true checks
			temp = TypeOfEqualsGenericInlined<string, string>();
			temp = TypeOfEqualsGenericInlined<int, int>();
			temp = TypeOfEqualsGenericInlined<double, double>();
			temp = TypeOfEqualsGenericInlined<decimal, decimal>();
			temp = TypeOfEqualsGenericInlined<byte, byte>();
			temp = TypeOfEqualsGenericInlined<short, short>();

			// false checks
			temp = TypeOfEqualsGenericInlined<string, int>();
			temp = TypeOfEqualsGenericInlined<int, string>();
			temp = TypeOfEqualsGenericInlined<double, int>();
			temp = TypeOfEqualsGenericInlined<decimal, int>();
			temp = TypeOfEqualsGenericInlined<byte, int>();
			temp = TypeOfEqualsGenericInlined<short, int>();
		}

		struct Operator_is_struct<A, B> { }
		static bool Operator_is<A, B>() => default(Operator_is_struct<A, B>) is Operator_is_struct<A, A>;

		[Benchmark]
		public void StructWrappedIs()
		{
			// true checks
			temp = Operator_is<string, string>();
			temp = Operator_is<int, int>();
			temp = Operator_is<double, double>();
			temp = Operator_is<decimal, decimal>();
			temp = Operator_is<byte, byte>();
			temp = Operator_is<short, short>();

			// false checks
			temp = Operator_is<string, int>();
			temp = Operator_is<int, string>();
			temp = Operator_is<double, int>();
			temp = Operator_is<decimal, int>();
			temp = Operator_is<byte, int>();
			temp = Operator_is<short, int>();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		static bool Operator_is_inlined<A, B>() => default(Operator_is_struct<A, B>) is Operator_is_struct<A, A>;

		[Benchmark]
		public void StructWrappedIsInlined()
		{
			// true checks
			temp = Operator_is_inlined<string, string>();
			temp = Operator_is_inlined<int, int>();
			temp = Operator_is_inlined<double, double>();
			temp = Operator_is_inlined<decimal, decimal>();
			temp = Operator_is_inlined<byte, byte>();
			temp = Operator_is_inlined<short, short>();

			// false checks
			temp = Operator_is_inlined<string, int>();
			temp = Operator_is_inlined<int, string>();
			temp = Operator_is_inlined<double, int>();
			temp = Operator_is_inlined<decimal, int>();
			temp = Operator_is_inlined<byte, int>();
			temp = Operator_is_inlined<short, int>();
		}

		public static class Cache<A, B>
		{
			public static bool Equal = typeof(A) == typeof(B);
		}

		[Benchmark]
		public void CachedTypeEquality()
		{
			// true checks
			temp = Cache<string, string>.Equal;
			temp = Cache<int, int>.Equal;
			temp = Cache<double, double>.Equal;
			temp = Cache<decimal, decimal>.Equal;
			temp = Cache<byte, byte>.Equal;
			temp = Cache<short, short>.Equal;

			// false checks
			temp = Cache<string, int>.Equal;
			temp = Cache<int, string>.Equal;
			temp = Cache<double, int>.Equal;
			temp = Cache<decimal, int>.Equal;
			temp = Cache<byte, int>.Equal;
			temp = Cache<short, int>.Equal;
		}
	}
}
